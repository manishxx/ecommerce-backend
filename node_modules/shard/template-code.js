function htmlEscape(str) {
	return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
return function (_data, _callback) {
	var _html = [];
	var _print = function (html) {
		_html.push(html);
	};
	var _pending = 1;
	function _decrementPending(error) {
		if (!--_pending) {
			_pending = -1e6; // Only return once
			_callback(error || null, _html.join(''));
		}
	}
	function _error(error) {
		_print('ERROR: ' + htmlEscape(error.message));
		_pending = 1;
		_decrementPending(error);
	}
	function print() { // Print all arguments, function never gets replaced
		for (var i = 0; i < arguments.length; i++) {
			_print(arguments[i]);
		}
	}
	function printSpecial(s, value) {
		if (_s[s]) return _print(_s[s](value));
		return 'invalid';
	}
	function shard(callback) {
		_pending++;
		var id = Math.random();
		_print(id);
		var result = function () {
			var oldPrint = _print;
			var index = _html.indexOf(id);
			_html.splice(index, 1);
			_print = function (html) {
				_html.splice(index++, 0, html);
			};
			try {
				callback.apply(this, arguments);
			} catch (e) {
				return _error(e);
			}
			_decrementPending();
			_print = oldPrint;
		};
		result.length = callback.length; // Don't even know if this works
		return result;
	}
	try {
		with (_data) {
			/*CODE*/
		}
	} catch (e) {
		return _error(e);
	}
	if (_pending === 1 && !_callback) {
		// TODO: if callback is not set but pending is true, return a stream
		var _result;
		_callback = function (e, r) {
			_result = r;
		};
		_decrementPending();
		return _result;
	} else {
		setTimeout(_decrementPending.bind(null, null), 0);
	}
};
